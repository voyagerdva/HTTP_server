Техническое задание (от 2019-10-25)
по созданию HTTP-сервера
 
1. ВВЕДЕНИЕ

2. НАЗНАЧЕНИЕ РАЗРАБОТКИ
	HTTP-сервер - это первый этап разработки ПО, предназначенного для взаимодействия (отправки запросов к.л. данных по определенным критериям, "координатам" в таблицах базы, добавление новых и изменение/удаление существующих записей в таблицах базы) с удаленной базой данных через адресную строку браузера, либо иные формы отправления запросов. Каждый запрос состоит из 3-Х частей:
		1. хост: IP-адрес хоста и порт - для доступа к HTTP-серверу;
		2. URL-путь: Содержит название таблицы в базе и, через "/", название оператора в базе (select, update, insert, delete). ПУТЬ добавляется через знак "/" после порта;
		3. тело: информация в формате JSON (либо словаря Python) с ключом - поле базы, и его значением - значением поля базы, оформленными в кавычки. Тело предназначено для изменения существующих и добавления новых записей в таблицу базы.
	Сам HTTP-сервер предназначен для принятия запросов от клиента, их обработки и в обработанном виде отправки их в другие модули для непосредственного взаимодействия с таблицами базы.
	
3. ТРЕБОВАНИЯ К ПРОГРАММЕ (ОБЩИЕ ТРЕБОВАНИЯ, СОСТАВ, ФУНКЦИОНАЛ)
3.1 ОБЩИЕ ТРЕБОВАНИЯ. В общем случае HTTP-сервер должен выполнять следующие функции:
>>>
3.1.1. 	принимать POST-запросы от клиента, сформированные по следующему шаблону (пример):
			URL			: "http://localhost:9920/users/insert"
							где	:
							host = http://localhost:9920
							ПУТЬ(path) = /users/insert
			ТЕЛО(body)	: {'name': 'Jhon', 'lastName': 'Smith', 'age': '4', 'address': 'USA, Whashington, st.Cooler, 75'}
			Header 		: {'Content-type': 'application/json', 'Accept': 'text/plain'}
>>>	
3.1.2.	В ответ отправлять клиенту путь (строка), как в запросе (/users/insert) и ТЕЛО JSON {'id': ' xxx ', 'name': 'Jhon', 'lastName': 'Smith', 'age': '4', 'address': 'USA, Whashington, st.Cooler, 75'},
	где id - заголовок поля 'id' нового юзера, значение которого - 'xxx' - база сообщит в ответ на создание новой записи, 
	
3.1.3. 	принимать GET-запросы, сформированные по следующему шаблону (пример):
			URL			: "http://localhost:9920/users/insert"
							где	:
							host = http://localhost:9920
							ПУТЬ(path) = /users/insert
			Header 		: {'Content-type': 'application/json', 'Accept': 'text/plain'}
	
3.1.4.	В ответ отправлять клиенту строку вида 'путь + имя_функции_обработчика_в_классе_MyController'.

3.1.5. Извлекать ТЕЛО и ПУТЬ из POST-запросов.
	
3.1.6. вызывать метод (функция_обработчика_в_классе_MyController), соответствующий первому слову в ПУТИ - названию таблицы (к примеру users, product, order)
	
3.1.7. в этот метод передать ДВА ПАРАМЕТРА:	1 - оставшуюся часть ПУТИ (т.е. "/insert")
											2 - тело
											
3.1.8. Этот метод должен вызвать метод класса ДАО, соответствующий оператору из пути - insert, и передать в него данные из ТЕЛА.

3.1.9. Метод ДАО "insertRecord" должен обратиться к базе, и добавить в таблицу "users" запись с данными из ТЕЛА. Названия полей (столбцы) соответствуют ключам в ТЕЛЕ. Записываемые значения - соответсующие значения ключей. 
											
3.1.9. После исполнения метода "insertRecord" должен быть выполнен метод "selectRecords" , который должен обратиться к таблице, и выбрать запись по заданным критериям (только что внесенные значения). Метод должен получить всю запись, включая значение поля "id", и передать эти данные в метод_обработчик_MyController.

3.1.10. метод_обработчик_MyController должен принять эти данные, пристегнуть к ним название метода в ДАО и название таблицы ("users/insertRecord") и все вместе передать в метод POST. 
											
3.1.11. метод POST должен отправить ответ клиенту с ответом от метода_обработчика_MyController в следующем виде: строка с названием метода в ДАО и названием таблицы ("users/insertRecord") и JSON-блок с данными только что добавленной записи из таблицы "users".

3.2 СОСТАВ ПРОГРАММЫ
	Состав HTTP-сервера должен быть следующий:
	
3.2.1 - класс MyServer(BaseHTTPRequestHandler):
			метод do_GET
			метод do_POST
			
3.2.2 - класс MyController:
			метод-обработчик (анализатор) ПУТИ - выбирает, к какой таблице идет запрос
			методы, отправляющие данные в модуль работы с базой (DAO)
			
3.2.3 - класс DAO:
			методы, работающие с базой
			(insert,
			update
			select
			delete
			и пр.)

3.3	ФУНКЦИОНАЛ ПРОГРАММЫ (ФУНКЦИОНАЛ КАЖДОГО МОДУЛЯ и метода)
3.3.1 класс MyServer(BaseHTTPRequestHandler):
3.3.1.1. метод do_POST :
		а) 	принимает POST-запросы, сформированные по следующему шаблону (пример):
			URL			: "http://localhost:9920/users/insert"
							где	:
							host = http://localhost:9920
							ПУТЬ(path) = /users/insert
			ТЕЛО(body)	: {'name': 'Jhon', 'lastName': 'Smith', 'age': '4', 'address': 'USA, Whashington, st.Cooler, 75'}
			Header 		: {'Content-type': 'application/json', 'Accept': 'text/plain'}
		б)	выделяет из запроса ПУТЬ (.path)
								ТЕЛО (.rfile.read)
	>>>	в)	вызывает метод (функция_обработчик_MyController), соответствующий первому слову в ПУТИ - названию таблицы (к примеру users)
		
	>>>	г)	в этот метод передать ДВА ПАРАМЕТРА:	1 - оставшуюся часть ПУТИ (т.е. "/insert")
													2 - тело
		
	>>>	д)	отправляет ответ клиенту с ответом от метода_обработчика_MyController в следующем виде: строка с названием метода в ДАО и названием таблицы ("users/insertRecord") и JSON-блок с данными только что добавленной записи из таблицы "users".
		
3.3.1.2. метод do_GET :
		а) 	принимает GET-запросы, сформированные по следующему шаблону (пример):
			URL		: "http://localhost:9920/users/insert"
							где	:
							host = http://localhost:9920
							ПУТЬ(path) = /users/insert
			Header 	: {'Content-type': 'application/json', 'Accept': 'text/plain'}
		б)	выделяет из запроса ПУТЬ (.path)
		в)	передает ПУТЬ в MyController
		г)	принимает от MyController строку вида 'ПУТЬ+имя_функции_обработчика_в_классе_MyController'  которую потом возвращает клиенту (метод self.wfile.write(ответ)

3.3.2 класс MyController
3.3.2.1. метод controller:
		а) принимает:
			от do_POST 	- ПУТЬ и ТЕЛО, 
			от do_GET 	- ПУТЬ;
		б) анализирует ПУТЬ - выделяет первое слово в ПУТИ и, в зависимости от этого слова (users) вызывает один из нескольких методов
		в) функции_обработчики_MyController, каждый из которых соответствует определенной команде, отправляемой в базу (из класса  DAO), которые должны подготавливать и передавать данные в DAO (здесь имеется ввиду update, insert, delete, select);
		г) передает этим функциям_обработчикам остаток ПУТИ (без первого слова) и ТЕЛО (если do_GET - то только ПУТЬ);
	>>>	д) вызвает метод класса ДАО, соответствующий оператору из пути - insert, и передает в него данные из ТЕЛА.
	>>>	е) принимает ответ от ДАО, пристегивает к нему название метода в ДАО и название таблицы (получается "users/insertRecord") и все вместе передает в метод POST. 

3.3.2.2. функции_обработчики - методы работы с базой - userInsert, userUpdate, userSelect, userDelete
		а) вызвают методы класса ДАО, соответствующие оператору из пути - например, insert, и передают в него данные из ТЕЛА.
	
3.3.3 класс DAO
3.3.3.1. Метод ДАО "insertRecord" - обращается к базе и добавляет в таблицу "users" запись с данными из ТЕЛА. Названия полей (столбцы) соответствуют ключам в ТЕЛЕ. Записываемые значения - соответсующие значения ключей. 
3.3.3.2. После исполнения метода "insertRecord" должен быть выполнен метод "selectRecords" , который должен обратиться к таблице, и выбрать запись по заданным критериям (только что внесенные значения). Метод должен получить всю запись, включая значение поля "id", и передать эти данные в метод_обработчик_MyController.

	
5. ТРЕБОВАНИЯ К ПРОГРАММНОЙ ДОКУМЕНТАЦИИ

6. ПОРЯДОК КОНТРОЛЯ И ПРИЕМКИ (описание процесса тестирования ПО):
6.1 ОБЩИЕ СВЕДЕНИЯ.
Проверка работы HTTP-сервера будет вестись путем тестирования. Всего различают 3 вида тестирования:
 - Интеграционные тесты;
 - Функциональные тесты;
 - Юнит-тесты.
 
6.2 ИНТЕГРАЦИОННЫЕ ТЕСТЫ.
В данной работе к HTTP-серверу будут применяться ИНТЕГРАЦИОННЫЕ ТЕСТЫ.

6.2.1	Требования к общей методике тестирования. Суть тестов.
		Требуется протестировать выполнение HTTP-сервером требований настоящего ТЗ по пунктам:
			- 3.1.1. 	принимать от клиента POST-запросы ...
			- 3.1.2. 	принимать от клиента GET-запросы ...
			- 3.1.11.	метод POST должен отправить ответ клиенту с ответом от метода_обработчика_MyController в следующем виде: строка с названием метода в ДАО и названием таблицы ("users/insertRecord") и JSON-блок с данными только что добавленной записи из таблицы "users".

6.2.2	Методика тестирования. Конкретные действия.
6.2.2.1. Создается фикстура fixtureHTTPPostUsersInsertJhonSmith с данными:
			myHOST	: 	"http://localhost:9900"
			myPATH	:	"/users/insert"
			myBODY	: 	{'name': 'Jhon', 'lastName': 'Smith', 'age': '4', 'address': 'USA, Whashington, st.Cooler, 75'} - эти данные получаются в результате сериализации экземпляра JhonSmith класса Users
			myHeaders	: 	{'Content-type': 'application/json', 'Accept': 'text/plain'}
>>>		
6.2.2.2. Пишутся тесты по следующей схеме:
		а) 	в папке "dbhttpserver\testunit\" создать папку "tests", в которую переносятся все предыдущие тесты;
		
		б) 	в той же папке "dbhttpserver\testunit\" создать папку "Entities", в которой будут храниться файлы-модули с классами, каждый из которых будет описывать свою таблицу (класс "Users", класс "Orders" и т.д.);
		
		в) 	в папке "dbhttpserver\testunit\Entities" создать файл "Users", в котором создать класс "Users";
		
		г)	в классе Users определить 5 полей:
			'id'
			'name' 
			'lastName'
			'age'
			'address'
		
		д) 	в фикстуре fixtureHTTPPostUsersInsertJhonSmith создать объект Jhon класса Users и сериализовать его для получения блока данных myBODY в формате JSON;
		П р и м е ч а н и е - стандартная операция сериализации объекта (.dumps()) возвращает тип "строка", а не JSON, и не dict. Но другая стандартная операция (.loads()) к полученной сериализованной строке формирует формат dict.
		
		д1)	в фикстуре fixtureHTTPPostUsersInsertJhonSmith создать дополнительный блок данных, совпадающий с тем, что генерится в сервере, с именем myBODYtest. С ним и будет идти сравнение данных, полученных в ответе от сервера;
		
		е) на стороне сервера в MyController создать класс Users;
		
		ж) в классе Users определить 5 полей:
			'id'
			'name' 
			'lastName'
			'age'
			'address'
		
		з) создать объект Jhon класса Users и сериализовать его для получения блока данных с именем respBodyJhon в формате JSON;
		
		и) функция_обработчик_MyController должна возвращать в метод do_POST ПУТЬ и ТЕЛО respBodyJhon;
		
		к) ответ сервера клиенту (в ответ на тестовый запрос resp) должен содержать путь и ТЕЛО respBodyJhon;
		
		л) respBodyJhon должен выделяться на стороне теста и сравниваться с myBODY;
		
		м) в Имя теста: test_HTTPPostUsersInsert;
        н) кортеж с переменными, из которых формируется запрос, значения принимаются из фикстуры: 
            (myHOST, myPATH, myBODY, myHeaders, myBODYtest, myPATHtest) = fx.fixtureHTTPPostUsersInsertJhonSmith();
        о) формируется объект запроса вида :
                  resp = requests.post(myHOST+myPATH, headers=myHeader, json=myBody)
		п) получается ответ от HTTP-сервера методом resp.text 
		р) из полученного ответа выделяется 'ПУТЬ' и 'ТЕЛО'
		с) 'ПУТЬ' сравнивается с myPATH , 'ТЕЛО' сравнивается с myBODYtest.
		
		П р и м е ч а н и я : 
		1. Разработка работы сервера с базой начинается с подготовки тестов.
		2. В контроллере, пока отлаживаются тесты - функция userInsert является заглушкой, т.е. она просто возвращает нужный JSON, как будто это ответ базы

6.3	ФУНКЦИОНАЛЬНЫЕ ТЕСТЫ

6.4 ЮНИТ-ТЕСТЫ
	это выполнение тестов по пунктам ТЗ:
		3.2.1.1
		3.2.2.1
		3.2.3.ххх
		и т.д.
		
	сейчас этих тестов не будет !!!
































































